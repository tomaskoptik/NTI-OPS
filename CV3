#include "mbed.h"
#include "stm32746g_discovery_lcd.h"
#include "stm32746g_discovery_ts.h"
#include <stdlib.h>
#include <time.h>
#define YELLOW_FLAG 1
#define BLUE_FLAG 2
#define CYAN_FLAG 3
#define X_YELLOW 30
#define Y_YELLOW BSP_LCD_GetYSize() / 2 - 50
#define X_BLUE BSP_LCD_GetXSize() / 3 + 30
#define Y_BLUE BSP_LCD_GetYSize() / 2 - 50
#define X_CYAN 2 * (BSP_LCD_GetXSize() / 3) + 30
#define Y_CYAN BSP_LCD_GetYSize() / 2 - 50
#define RECT_SIZE 100
Ticker ticker;
EventFlags eventFlags;
int milliseconds = 10000;
Thread actionThread;
Thread touchScreen;
Watchdog &watchdog = Watchdog::get_instance();
int *randomNumbers = (int *)malloc(sizeof(int) * 3);
void myShuffle(int *array, int n) {
    if (n > 1) {
    srand((unsigned int)time(NULL));
    int i;
    for (i = n - 1; i > 0; i--) {
    int j = rand() % (i + 1);
    int t = array[i];
    array[i] = array[j];
    array[j] = t;
}
}
}
void explode() {
    myShuffle(randomNumbers, 3);
    ticker.detach();
    BSP_LCD_Clear(LCD_COLOR_RED);
    watchdog.start(5000);
}
void resetTimer() {
    myShuffle(randomNumbers, 3);
    milliseconds = 10000;
    watchdog.start(15000);
}
void success() {
    ticker.detach();
    while (true) {
    watchdog.kick();
}
}
void action() {
    uint32_t flagsRead = 0;
    while (true) {
    flagsRead = eventFlags.wait_any(YELLOW_FLAG | BLUE_FLAG | CYAN_FLAG);
    switch (flagsRead) {
    case 1:
        explode();
    break;
    case 2:
        resetTimer();
    break;
    case 3:
        success();
        break;
    }
}
}
void fillArray(int *array) {
*array = 1;
*(array + 1) = 2;
*(array + 2) = 3;
}
void readTouchScreen() {
    TS_StateTypeDef TS_State;
    uint16_t x, y;
    uint8_t status = BSP_TS_Init(BSP_LCD_GetXSize(), BSP_LCD_GetYSize());
    while (true) {
        BSP_TS_GetState(&TS_State);
        static time_t lastTouchTime = 0;
        time_t currentTime = time(NULL);
        if (currentTime - lastTouchTime >= 1) {
        if (TS_State.touchDetected) {
        if (TS_State.touchX[0] >= X_YELLOW &&
        TS_State.touchX[0] <= X_YELLOW + RECT_SIZE &&
        TS_State.touchY[0] >= Y_YELLOW &&
        TS_State.touchY[0] <= Y_YELLOW + RECT_SIZE) {
        eventFlags.set(randomNumbers[0]);
        } else if (TS_State.touchX[0] >= X_BLUE &&
        TS_State.touchX[0] <= X_BLUE + RECT_SIZE &&
        TS_State.touchY[0] >= Y_BLUE &&
        TS_State.touchY[0] <= Y_BLUE + RECT_SIZE) {
        eventFlags.set(randomNumbers[1]);
        } else if (TS_State.touchX[0] >= X_CYAN &&
        TS_State.touchX[0] <= X_CYAN + RECT_SIZE &&
        TS_State.touchY[0] >= Y_CYAN &&
        TS_State.touchY[0] <= Y_CYAN + RECT_SIZE) {
        eventFlags.set(randomNumbers[2]);
        }
        lastTouchTime = currentTime;
        }
        }
        }
    }

void displayTime() {
    if (milliseconds > 0) {
        milliseconds -= 100;
        int centiseconds = milliseconds / 10;
        char secondsStr[128];
        snprintf(secondsStr, sizeof(secondsStr), "%d.%01d seconds",
        centiseconds / 100, (centiseconds / 10) % 10);
        BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
        BSP_LCD_DisplayStringAt(0, 1, (uint8_t *)secondsStr, CENTER_MODE);
    } else if (milliseconds == 0) {
        BSP_LCD_Clear(LCD_COLOR_RED);
    } else {
        ticker.detach();
    }
}
void bspLcdInit() {
    BSP_LCD_Init();
    BSP_LCD_LayerDefaultInit(LTDC_ACTIVE_LAYER, LCD_FB_START_ADDRESS);
    BSP_LCD_SelectLayer(LTDC_ACTIVE_LAYER);
    BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
    BSP_LCD_Clear(LCD_COLOR_WHITE);
}
void fillButtons() {
    BSP_LCD_SetTextColor(LCD_COLOR_YELLOW);
    BSP_LCD_FillRect(X_YELLOW, Y_YELLOW, RECT_SIZE, RECT_SIZE);
    BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
    BSP_LCD_FillRect(X_BLUE, Y_BLUE, RECT_SIZE, RECT_SIZE);
    BSP_LCD_SetTextColor(LCD_COLOR_CYAN);
    BSP_LCD_FillRect(X_CYAN, Y_CYAN, RECT_SIZE, RECT_SIZE);
}
int main() {
    fillArray(randomNumbers);
    myShuffle(randomNumbers, 3);
    bspLcdInit();
    fillButtons();
    ticker.attach(&displayTime, 100ms);
    watchdog.start(15000);
    actionThread.start(callback(action));
    touchScreen.start(callback(readTouchScreen));
}
